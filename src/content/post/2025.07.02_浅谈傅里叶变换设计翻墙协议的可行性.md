---
title: 浅谈傅里叶变换设计翻墙协议的可行性
description: 这是一篇有意思的文章
publishDate: 2025-07-02
ogImage: /social-card.avif
---
由于FPRT的可逆性、以及经过FRFT加工的数据不像tls那样具有明确的结构特征，能够规避部分流量检测，且不同阶数的FRFT转换具有不同“混淆性”，无法直接识别明文频谱。所以使用FRFT作为翻墙协议是可行的\
\
简单的框架可如下设计：\
客户端数据加密流程：\
明文数据（如HTTP请求）→ 对称加密（如 AES-256）→ FRFT 分数阶变换（α ≠nπ/2）→ 分包编码 & TCP/UDP 封装→ 发送到代理服务器

服务器解密流程：\
接收封包→ 分包重组→ 逆FRFT（α → -α）→ 对称解密→ 获取明文数据

FRFT的数据在频谱中呈现非结构性的波动，可以很好的对抗DPI\
其变换阶数也可以做成动态的，加强其混淆性，可以做成动态口令的形式，类似Trojan/V2Ray，通过TLS或外部预认证通道传输密钥和变换阶数\
\
以下是使用AI按照上述思路简单完成的一个样本\
为了方便在使用前需要安装 pyfrft 库（不然就要自己实现分数傅里叶了，/(ㄒoㄒ)/\~\~

```
import numpy as np
from frft import frft
from Crypto.Cipher import AES
import socket

def aes_encrypt(data: bytes, key: bytes) -> bytes:
    cipher = AES.new(key, AES.MODE_EAX)
    ciphertext, tag = cipher.encrypt_and_digest(data)
    return cipher.nonce + tag + ciphertext

def aes_decrypt(data: bytes, key: bytes) -> bytes:
    nonce, tag, ciphertext = data[:16], data[16:32], data[32:]
    cipher = AES.new(key, AES.MODE_EAX, nonce=nonce)
    return cipher.decrypt_and_verify(ciphertext, tag)

def apply_frft(data: bytes, alpha: float) -> bytes:
    signal = np.frombuffer(data, dtype=np.uint8).astype(np.float32)
    transformed = frft(signal, alpha)
    return transformed.astype(np.float32).tobytes()

def inverse_frft(data: bytes, alpha: float) -> bytes:
    signal = np.frombuffer(data, dtype=np.float32)
    recovered = frft(signal, -alpha)
    return np.clip(recovered, 0, 255).astype(np.uint8).tobytes()

```



\
\
由于FRFT并没有任何硬性要求，不会像Trojan那样出现没有原生UDP的尴尬情况，所以L4用什么协议完全是自主决定，可以使用UDP，为了安全也可以再加一层TLS OVER TCP，但是鉴于tls in tls已经能被精准识别，所以可以使用anytls进行外层封装避免被DPI检测

在回源结构上，可以仿照CDN的回源结构，使用CF隐藏源IP\
但是这样却必须进行ws回源，反而会出现特征，所以是否使用后期待定
